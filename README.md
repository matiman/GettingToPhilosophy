# GettingToPhilosophy
Getting To Philosophy


 Objective

Your goal is to build a front-end form that takes an input of a Wikipedia URL and interacts with a back-end API you’ve built. It will store the data in a database you’ve designed, and print out the path taken from clicking the first link of each page to get to Philosophy.


The API should take a single Wikipedia link as input, should visit the given page, and keep going through the first link on each next page until Philosophy is reached. The path taken should be stored in the database with a unique identifier for any given path. The front-end should display the path taken to reach Philosophy. It should also display the amount of hops it took to get to the page.

 Here’s some more reading about how the back-end should work: “Getting to Philosophy”.
 Design of the form isn’t important. But code quality is.


 Some hints

Because not every single link will lead to Philosophy, think about defining a maximum number of hops

Think about how to handle if/when you get stuck in a loop

Find out how to ignore citations/sound/extraneous links

===========================================Solution==========================================
In order to see how this API works try to look at the following link http://www.xefer.com/wikipedia.
Type a title and it will show you a path to philosophy page.

On wikipedia page clicking every first link that is not italic, citation,external link, and a sound link, will finally lead to Philsophy.
For e.g if u go to en.wikipedia.org/wiki/Awareness and click the first link that satisfies the above condition,it will lead you to 
en.wikipedia.org/wiki/Awareness repeating the same process will lead us finally to Philsophy page.
http://en.wikipedia.org/wiki/Conscis
http://en.wikipedia.org/wiki/Consciousness
http://en.wikipedia.org/wiki/Quality_(philosophy)
http://en.wikipedia.org/wiki/Philosophy

Wikipedia has an api that exposes the "wiki text" (somehow formatted)of each page. All you have to do is add "?action=raw" at the end of each link
for e.g http://en.wikipedia.org/wiki/Quality_(philosophy)?action=raw will give us a text like the following

{{about|quality in the philosophical sense||quality (disambiguation)}}
In [[philosophy]], a '''quality''' (from [[Latin]] ''qualitas'')<ref>Morwood, J. (Ed.) (1995). ''The Pocket Oxford Latin Dictionary.'' Oxford</ref> is an attribute or a [[Property (philosophy)|property]].<ref name="Cargile, 1995">Cargile, J. (1995). qualities. in Honderich, T. (Ed.) (2005). ''The Oxford Companion to Philosophy'' (2nd ed.). Oxford</ref> In [[contemporary philosophy]] the [[idea]] of qualities, and especially how to distinguish certain kinds of qualities from one another, remains controversial.<ref name="Cargile, 1995"/>

==Background==
{{further|Property (philosophy)}}
[[Aristotle]] analyzed qualities in his [[logic]]al work, the ''[[Categories (Aristotle)|Categories]]''. To him, qualities are [[hylomorphic]]ally–formal attributes, such as "white" or "grammatical". Categories of ''state'', such as "shod" and "armed" are also non–[[essential property|essential]] qualities ''([[sumbebekos|katà symbebekós]])''.<ref name="MIT_Cat_70">{{cite web |url=http://classics.mit.edu/Aristotle/categories.1.1.html#70 |author=Edghill, E.M. trans. |title=The Internet Classics Archive – Aristotle ''Categories'' |publisher=MIT |year=2009}} line 70.</ref> Aristotle observed: "one and the selfsame substance, while retaining its identity, is yet capable of admitting contrary qualities. The same individual person is at one time white, at another black, at one time warm, at another cold, at one time good, at another bad. This capacity is found nowhere else... it is the peculiar mark of substance that it should be capable of admitting contrary qualities; for it is by itself changing that it does so".<ref name="MIT_Cat_254">{{cite web |url=http://classics.mit.edu/Aristotle/categories.1.1.html#254 |author=Edghill, E.M. trans. |title=The Internet Classics Archive – Aristotle ''Categories'' |publisher=MIT |year=2009}} line 254.</ref> Aristotle described four types of qualitative opposites: ''correlatives,'' ''contraries,'' ''privatives'' and ''positives.''<ref name=autogenerated1>{{cite web |url=http://classics.mit.edu/Aristotle/categories.3.3.html#254 |author=Edghill, E.M. trans. |title=The Internet Classics Archive – Aristotle ''Categories'' |publisher=MIT |year=2009}} line 28.</ref>

I looked at more than 50 pages to look at their similarity and all of the have their first link appear in a dobule square bracket
like [[THIS]]. This text shouldn't be rapped inside any brackets. If that is the case you have to skip it.

In the above case our link is  [[philosophy]] . 

The API I wrote in Java fetches this data, parse it to find the first link store in a database (if the path title doesn't exist in the database)
If the path already exists in the database it will return that path instead of fetching the data from wiki api which
is a bit faster. 
The database schema I used is pretty simple( though I believe there is a bettwer which I will explain latter)
SCHEMA: 
CREATE TABLE philosophy(
   title CHAR(50) PRIMARY KEY     NOT NULL,
   path         TEXT    NOT NULL
);
I have checked that all the title names are different(from the 50 pages I saw). So I made title to be the primary key.
When I find a title of a page, first I check the database and if it exists I printit out if not I fetch the wiki text and process it unti I reach to philosophy. For the first few users who will use the API, it will cost them time since I have to fetch from wiki and save to db but once I have a lot of data loaded in it, once you come and search the title, you will most likely find it in DB so it will save us from hitting the wiki api. 

There is a match faster way to do this( since time was a constraint I haven't implemented it). Here is one problem with this approach. 
For e.g we have a titlel X( for simplicity) then X's first link Y. Then Y's first link is Z and so on.
X->Y->Z>A->B->Philosophy. Now we have a data like this in our table
title   Path
X       [X,Y,Z,A,B,Philosophy]
If someone comes and try to find the path from X>Philsophy, Voila ! We have it so we can give it back to him. But if someone comes and look for Z? Now we hace to fetch wiki api again to find the path and store. The efficient way to do this would be, in my opinion, to store a title and its next path. So for the above scenario, our table should look like
title  next
X       Y
Y       Z
Z       A
A       B
B    Philosophy.

This way when future users come, we not only serve for X from the database but also for the other titles(Y,Z,A,B).
